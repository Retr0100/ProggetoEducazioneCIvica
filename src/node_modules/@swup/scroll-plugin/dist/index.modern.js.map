{"version":3,"file":"index.modern.js","sources":["../src/index.js"],"sourcesContent":["import Plugin from '@swup/plugin';\nimport { getCurrentUrl, Location, queryAll } from 'swup';\nimport Scrl from 'scrl';\n\n/**\n * Class representing a Scroll Plugin.\n * @extends Plugin\n */\nexport default class ScrollPlugin extends Plugin {\n\tname = 'ScrollPlugin';\n\n\t/**\n\t * Constructor\n\t * @param {?object} options the plugin options\n\t */\n\tconstructor(options) {\n\t\tsuper();\n\t\tconst defaultOptions = {\n\t\t\tdoScrollingRightAway: false,\n\t\t\tanimateScroll: {\n\t\t\t\tbetweenPages: true,\n\t\t\t\tsamePageWithHash: true,\n\t\t\t\tsamePage: true\n\t\t\t},\n\t\t\tscrollFriction: 0.3,\n\t\t\tscrollAcceleration: 0.04,\n\t\t\tgetAnchorElement: null,\n\t\t\toffset: 0,\n\t\t\tscrollContainers: `[data-swup-scroll-container]`,\n\t\t\tshouldResetScrollPosition: (htmlAnchorElement) => true\n\t\t};\n\n\t\tthis.options = {\n\t\t\t...defaultOptions,\n\t\t\t...options\n\t\t};\n\t}\n\n\t/**\n\t * Runs if the plugin is mounted\n\t */\n\tmount() {\n\t\tconst swup = this.swup;\n\n\t\t// add empty handlers array for scroll events\n\t\tswup._handlers.scrollDone = [];\n\t\tswup._handlers.scrollStart = [];\n\n\t\t// Initialize Scrl for smooth animations\n\t\tthis.scrl = new Scrl({\n\t\t\tonStart: () => swup.triggerEvent('scrollStart'),\n\t\t\tonEnd: () => swup.triggerEvent('scrollDone'),\n\t\t\tonCancel: () => swup.triggerEvent('scrollDone'),\n\t\t\tfriction: this.options.scrollFriction,\n\t\t\tacceleration: this.options.scrollAcceleration\n\t\t});\n\n\t\t// set scrollTo method of swup and animate based on current animateScroll option\n\t\tswup.scrollTo = (offset, animate = true) => {\n\t\t\tif (animate) {\n\t\t\t\tthis.scrl.scrollTo(offset);\n\t\t\t} else {\n\t\t\t\tswup.triggerEvent('scrollStart');\n\t\t\t\twindow.scrollTo(0, offset);\n\t\t\t\tswup.triggerEvent('scrollDone');\n\t\t\t}\n\t\t};\n\n\t\t// This object will hold all scroll positions\n\t\tthis.scrollPositionsStore = {};\n\t\t// this URL helps with storing the current scroll positions on `willReplaceContent`\n\t\tthis.currentCacheKey = this.getCurrentCacheKey();\n\n\t\t// disable browser scroll control on popstates when\n\t\t// animateHistoryBrowsing option is enabled in swup.\n\t\t// Cache the previous setting to be able to properly restore it on unmount\n\t\tthis.previousScrollRestoration = window.history.scrollRestoration;\n\t\tif (swup.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t// scroll to the top of the page\n\t\tswup.on('samePage', this.onSamePage);\n\n\t\t// scroll to referenced element on the same page\n\t\tswup.on('samePageWithHash', this.onSamePageWithHash);\n\n\t\t// scroll to the referenced element\n\t\tswup.on('transitionStart', this.onTransitionStart);\n\n\t\t// scroll to the referenced element when it's in the page (after render)\n\t\tswup.on('contentReplaced', this.onContentReplaced);\n\n\t\tswup.on('willReplaceContent', this.onWillReplaceContent);\n\t\tswup.on('clickLink', this.onClickLink);\n\t}\n\n\t/**\n\t * Runs when the plugin is unmounted\n\t */\n\tunmount() {\n\t\tconst swup = this.swup;\n\t\tswup.scrollTo = null;\n\n\t\tdelete this.scrl;\n\t\tthis.scrl = null;\n\n\t\tswup.off('samePage', this.onSamePage);\n\t\tswup.off('samePageWithHash', this.onSamePageWithHash);\n\t\tswup.off('transitionStart', this.onTransitionStart);\n\t\tswup.off('contentReplaced', this.onContentReplaced);\n\t\tswup.off('willReplaceContent', this.onWillReplaceContent);\n\t\tswup.off('clickLink', this.onClickLink);\n\n\t\tswup._handlers.scrollDone = null;\n\t\tswup._handlers.scrollStart = null;\n\n\t\twindow.history.scrollRestoration = this.previousScrollRestoration;\n\t}\n\n\t/**\n\t * Detects if a scroll should be animated, based on context\n\t * @param {string} context\n\t * @returns {boolean}\n\t */\n\tshouldAnimate(context) {\n\t\tif (typeof this.options.animateScroll === 'boolean') {\n\t\t\treturn this.options.animateScroll;\n\t\t}\n\t\treturn this.options.animateScroll[context];\n\t}\n\n\t/**\n\t * Get an element based on anchor\n\t * @param {string} hash\n\t * @returns {mixed}\n\t */\n\tgetAnchorElement = (hash = '') => {\n\t\t// Look for a custom function provided via the plugin options\n\t\tif (typeof this.options.getAnchorElement === 'function') {\n\t\t\treturn this.options.getAnchorElement(hash);\n\t\t}\n\t\t// Look for a the built-in function in swup, added in swup 2.0.16\n\t\tif (typeof this.swup.getAnchorElement === 'function') {\n\t\t\treturn this.swup.getAnchorElement(hash);\n\t\t}\n\t\t// Finally, return a native browser query\n\t\treturn document.querySelector(hash);\n\t};\n\n\t/**\n\t * Get the offset for a scroll\n\t * @param {(HtmlELement|null)} element\n\t * @returns {number}\n\t */\n\tgetOffset = (element = null) => {\n\t\t// If options.offset is a function, apply and return it\n\t\tif (typeof this.options.offset === 'function') {\n\t\t\treturn parseInt(this.options.offset(element), 10);\n\t\t}\n\t\t// Otherwise, return the sanitized offset\n\t\treturn parseInt(this.options.offset, 10);\n\t};\n\n\t/**\n\t * Handles `samePage`\n\t */\n\tonSamePage = () => {\n\t\tthis.swup.scrollTo(0, this.shouldAnimate('samePage'));\n\t};\n\n\t/**\n\t * Handles `onSamePageWithHash`\n\t * @param {PointerEvent} event\n\t */\n\tonSamePageWithHash = (event) => {\n\t\tconst link = event.delegateTarget;\n\t\tthis.maybeScrollToAnchor(link.hash, 'samePageWithHash');\n\t};\n\n\t/**\n\t * Attempts to scroll to an anchor\n\t * @param {string} hash\n\t * @param {string} context\n\t * @returns {boolean}\n\t */\n\tmaybeScrollToAnchor(hash, context) {\n\t\t// Bail early if the hash is null\n\t\tif (hash == null) {\n\t\t\treturn false;\n\t\t}\n\t\tconst element = this.getAnchorElement(hash);\n\t\tif (!element) {\n\t\t\tconsole.warn(`Element ${hash} not found`);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(element instanceof Element)) {\n\t\t\tconsole.warn(`Element ${hash} is not a DOM node`);\n\t\t\treturn false;\n\t\t}\n\t\tconst top =\n\t\t\telement.getBoundingClientRect().top + window.pageYOffset - this.getOffset(element);\n\t\tthis.swup.scrollTo(top, this.shouldAnimate(context));\n\t\treturn true;\n\t}\n\n\t/**\n\t * Handles `transitionStart`\n\t * @param {PopStateEvent} popstate\n\t */\n\tonTransitionStart = (popstate) => {\n\t\tif (this.options.doScrollingRightAway && !this.swup.scrollToElement) {\n\t\t\tthis.doScrollingBetweenPages(popstate);\n\t\t}\n\t};\n\n\t/**\n\t * Handles `contentReplaced`\n\t * @param {PopStateEvent} popstate\n\t */\n\tonContentReplaced = (popstate) => {\n\t\tif (!this.options.doScrollingRightAway || this.swup.scrollToElement) {\n\t\t\tthis.doScrollingBetweenPages(popstate);\n\t\t}\n\n\t\tthis.restoreScrollContainers(popstate);\n\t};\n\n\t/**\n\t * Scrolls the window, based on context\n\t * @param {(PopStateEvent|boolean)} popstate\n\t * @returns {void}\n\t */\n\tdoScrollingBetweenPages = (popstate) => {\n\t\tconst swup = this.swup;\n\n\t\t// Bail early on popstate and inactive `animateHistoryBrowsing`\n\t\tif (popstate && !swup.options.animateHistoryBrowsing) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Try scrolling to a given anchor\n\t\tif (this.maybeScrollToAnchor(swup.scrollToElement, 'betweenPages')) {\n\t\t\tswup.scrollToElement = null;\n\t\t\treturn;\n\t\t}\n\n\t\t// Finally, scroll to either the stored scroll position or to the very top of the page\n\t\tconst scrollPositions = this.getStoredScrollPositions(this.getCurrentCacheKey()) || {};\n\t\tconst top = (scrollPositions.window && scrollPositions.window.top) || 0;\n\t\t// Give possible JavaScript time to execute before scrolling\n\t\trequestAnimationFrame(() => swup.scrollTo(top, this.shouldAnimate('betweenPages')));\n\t};\n\n\t/**\n\t * Stores the current scroll positions for the URL we just came from\n\t */\n\tonWillReplaceContent = () => {\n\t\tthis.storeScrollPositions(this.currentCacheKey);\n\t\tthis.currentCacheKey = this.getCurrentCacheKey();\n\t};\n\n\t/**\n\t * Handles `clickLink`\n\t * @param {PointerEvent}\n\t * @returns {void}\n\t */\n\tonClickLink = (event) => {\n\t\tthis.maybeResetScrollPositions(event.delegateTarget);\n\t};\n\n\t/**\n\t * Deletes the scroll positions for the URL a link is pointing to,\n\t * if shouldResetScrollPosition evaluates to true\n\t * @param {HTMLAnchorElement} htmlAnchorElement\n\t * @returns {void}\n\t */\n\tmaybeResetScrollPositions(htmlAnchorElement) {\n\t\tif (!this.options.shouldResetScrollPosition(htmlAnchorElement)) {\n\t\t\treturn;\n\t\t}\n\t\tconst { url } = Location.fromElement(htmlAnchorElement);\n\t\tthis.resetScrollPositions(url);\n\t}\n\n\t/**\n\t * Stores the scroll positions for the current URL\n\t * @param {string} url\n\t * @returns {void}\n\t */\n\tstoreScrollPositions(url) {\n\t\t// retrieve the current scroll position for all containers\n\t\tconst containers = queryAll(this.options.scrollContainers).map((el) => ({\n\t\t\ttop: el.scrollTop,\n\t\t\tleft: el.scrollLeft\n\t\t}));\n\n\t\t// construct the final object entry, with the window scroll positions added\n\t\tthis.scrollPositionsStore[url] = {\n\t\t\twindow: { top: window.scrollY, left: window.scrollX },\n\t\t\tcontainers\n\t\t};\n\t}\n\n\t/**\n\t * Resets stored scroll positions for a given URL\n\t * @param {string} url\n\t */\n\tresetScrollPositions(url) {\n\t\tconst cacheKey = this.getResolvedUrl(url);\n\t\tdelete this.scrollPositionsStore[cacheKey];\n\t\tthis.scrollPositionsStore[cacheKey] = null;\n\t}\n\n\t/**\n\t * Get the stored scroll positions for a given URL from the cache\n\t * @returns {(object|undefined)}\n\t */\n\tgetStoredScrollPositions(url) {\n\t\tconst cacheKey = this.getResolvedUrl(url);\n\t\treturn this.scrollPositionsStore[cacheKey];\n\t}\n\n\t/**\n\t * Restore the scroll positions for all matching scrollContainers\n\t * @returns void\n\t */\n\trestoreScrollContainers(popstate) {\n\t\t// get the stored scroll positions from the cache\n\t\tconst scrollPositions = this.getStoredScrollPositions(this.getCurrentCacheKey()) || {};\n\t\tif (scrollPositions.containers == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// cycle through all containers on the current page and restore their scroll positions, if appropriate\n\t\tqueryAll(this.options.scrollContainers).forEach((el, index) => {\n\t\t\tconst scrollPosition = scrollPositions.containers[index];\n\t\t\tif (scrollPosition == null) return;\n\t\t\tel.scrollTop = scrollPosition.top;\n\t\t\tel.scrollLeft = scrollPosition.left;\n\t\t});\n\t}\n\t/**\n\t * Get the current cache key for the scroll positions.\n\t * @returns {string}\n\t */\n\tgetCurrentCacheKey() {\n\t\treturn this.getResolvedUrl(getCurrentUrl());\n\t}\n\t/**\n\t* Apply `swup.resolveUrl` to a given URL\n\t*\n\t* @returns {string}\n\t*/\n\tgetResolvedUrl(url) {\n\t\tif (typeof this.swup.resolveUrl === 'function') {\n\t\t\treturn this.swup.resolveUrl(url);\n\t\t}\n\t\treturn url;\n\t}\n}\n"],"names":["ScrollPlugin","Plugin","constructor","options","super","this","name","getAnchorElement","hash","swup","document","querySelector","getOffset","element","offset","parseInt","onSamePage","scrollTo","shouldAnimate","onSamePageWithHash","event","maybeScrollToAnchor","delegateTarget","onTransitionStart","popstate","doScrollingRightAway","scrollToElement","doScrollingBetweenPages","onContentReplaced","restoreScrollContainers","animateHistoryBrowsing","scrollPositions","getStoredScrollPositions","getCurrentCacheKey","window","top","requestAnimationFrame","onWillReplaceContent","storeScrollPositions","currentCacheKey","onClickLink","maybeResetScrollPositions","defaultOptions","animateScroll","betweenPages","samePageWithHash","samePage","scrollFriction","scrollAcceleration","scrollContainers","shouldResetScrollPosition","htmlAnchorElement","mount","_handlers","scrollDone","scrollStart","scrl","Scrl","onStart","triggerEvent","onEnd","onCancel","friction","acceleration","animate","scrollPositionsStore","previousScrollRestoration","history","scrollRestoration","on","unmount","off","context","console","warn","Element","getBoundingClientRect","pageYOffset","url","Location","fromElement","resetScrollPositions","containers","queryAll","map","el","scrollTop","left","scrollLeft","scrollY","scrollX","cacheKey","getResolvedUrl","forEach","index","scrollPosition","getCurrentUrl","resolveUrl"],"mappings":"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"}